C语言数据类型：基本类型、结构类型、指针类型、空类型(void)
    基本类型：数值类型、字符类型
        数值类型：整型(短整型short、整形int、长整型long)、浮点型(单精度型float、双精度型double)
        字符类型：char
    结构类型：数组、结构体(struct)、共用体(union)、枚举(enum)
    https://blog.csdn.net/sfg0861/article/details/123854902

反码的意义：将减法变为加法
补码的意义：弥补了加法运算的不足(结果为正数时，需要补码运算)
计算机存储的二进制数是称为机器数吗？
    答(个人)：是
    对于整型来说，数据在内存中存储的格式是补码
    在计算机系统中，数值一律用补码来表示和存储。
    原因是，使用补码可以将符号位和数值域统一处理。
    同时，加法和减法也可以统一处理
机器数是原码、反码还是补码？
    答(个人)：补码

    机器码:6e fd ff ff
    ff ff fd 6e
    1111 1111 1111 1111 1111 1101 0110 1110
    1111 1111 1111 1111 1111 1101 0110 1101
    1000 0000 0000 0000 0000 0010 1001 0010
    =-0010 1001 0010
    =-658

==>
数学公式在线编辑
    https://www.latexlive.com/
example0100.cpp
    单个字符类型无法使用scanf函数在控制台单个输入，因为换行时"\n"会进行覆盖输入。
        在%c面前加\n、空格、\t和进行输入的字符绑定，就可以进行输入了。或者使用getchar函数
            scanf(" %c",&c)
example0200.cpp
    在一个cpp文件中调用另一个cpp文件中的方法：定义头文件法
    在一个cpp文件中调用另一个cpp文件中的方法：函数调用声明法
example0300.cpp
    1、scanf_s()的使用方法，需要在变量后加变量大小(位数)。
    2、基本数据类型在scanf输入时，都应该用地址&，字符变量可以不加(&是取地址，而字符常量属于指针[地址])，但为了严谨还是加&。
example0400.cpp
    printf打印数据地址时，使用的是%p和&
example0401.cpp
    char(1字节=1*8位)类型的无符号和有符号溢出时取值情况。
    中间量：0x80(0B1000 0000)(无符号：128，有符号：-128)
    最大量：0xFF(0B1111 1111)(无符号：255，有符号：-1)
example0402.cpp
    short(2字节=2*8位)类型的无符号和有符号溢出时取值情况。
    中间量：0x8000(0B1000 0000 0000 0000)(无符号：32768，有符号：-32768)
    最大量：0xFFFF(0B1111 1111 1111 1111)(无符号：65535，有符号：-1)
example0403.cpp
    int(4字节=4*8位)类型的无符号和有符号溢出时取值情况。
    中间量：0x80 00 00 00(0B1000 0000 0000 0000 0000 0000 0000 0000)(无符号：2147483648，有符号：-2147483648)
    最大值：0xFF FF FF FF(0B1111 1111 1111 1111 1111 1111 1111 1111)(无符号：4294967295，有符号：-1)
example0404.cpp
    打印类型变量的大小(字节数)：sizeof(类型变量)
example0405.cpp
    打印有符号和无符号类型变量的大小(字节数)：sizeof(类型变量)
example0406.cpp
    1、单精度型(float)变量有效数字为7位，双精度型(double)变量有效数字为16位。
    2、浮点型数据在机内用指数形式表示：符号位(数符、1位)、指数位(指数+指数符)、小数位(尾数)。
    3-1、指数位决定了取值范围，指数位可以分为有符号和无符号。
        float：8位，0B0111 1111=127，取值范围：2^[-127~128]
        double：11位，0B011 1111 1111=1023，取值范围：2^[-1023~1024]
    3-2、指数位存储时按无符号整数存储(因为以无符号形式存储，所以128可表示，-128不能表示[有符号存储时,0可分为-0和+0,-0表示-128])。以float为例：
        正数：6 =>6(要存储数)+127(指数位偏移量)=133=>0B1000 0101(存储数)
        负数：-3 =>-3(要存储数)+127(指数位偏移量)=124=>0B01111100(存储数)
    4、小数位决定了精度范围
        float：23位，0B111 1111 1111 1111 1111 1111=8388607，最大表示十进制7位，保证表示十进制6位
        double：52位，0B111 1111 .... 1111=4503599627370495，最大表示十进制16位，保证表示十进制15位
    
    ps：数据和机器码之间的转换举例
        (78.375)
        =(0B0100 1110)+(0.375)
        =0B0100 1110+(3/8)
        =0B0100 1110+(1/4+1/8)
        =0B0100 1110+(2^-2+2^-3)
        =0B0100 1110+(0B0.01+0B0.001)
        =0B0100 1110.011
        =1.001110011x2^6
        78.375 = 0 10000101 001110011 00000 00000 0000
        第一部分用来存储符号位(sign)，用来区分正负，0表示正数
        第二部分用来存储指数(exponent)，这里的指数是十进制的 6
        第三部分用来存储小数(fraction)，这里的小数部分是 001110011

        (float)
        机器码:00 c0 9c c2
        c2 9c c0 00
        1100 0010 1001 1100 1100 0000 0000 0000
        1 10000101 001 1100 1100 0000 0000 0000
        -1.001110011x2^(1000 0101-111 1111)
        =-1.001110011x2^(133-127)
        =-1.001110011x2^6
        =-1001110.011
        =-(78+1/(2^2)+1/(2^3))
        =-(78+0.25+0.125)
        =-78.375
        
        (double)89.0
        00 00 00 00 00 40 56 40
        40 56 40 00 00 00 00 00
        01000000 01010110 01000000 00000000 00000000 00000000 00000000 00000000
        0 10000000101 0110010000000000000000000000000000000000000000000000
        =1.011001 x 2^(10000000101 - 01111111111)
        =1.011001 x 2^(110)
        =1.011001 x 2^6
        =1011001
        =89

        (double)99.9
        9a 99 99 99 99 f9 58 40
        40 58 f9 99 99 99 99 9a
        01000000 01011000 11111001 10011001 10011001 10011001 10011001 10011010
        0 10000000101 1000111110011001100110011001100110011001100110011010
        =1.1000111110011001100110011001100110011001100110011010 x 2^(10000000101 - 01111111111)
        =1.1000111110011001100110011001100110011001100110011010 x 2^(110)
        =1.1000111110011001100110011001100110011001100110011010 x 2^6
        =1100011.1110011001100110011001100110011001100110011010
        =99+(1/2+1/4+1/8+1/64+1/128+...)
        =99+(0.5+0.25+0.125+0.015625+0.0078125+...)
        =99+0.8984375+...
        =99.8984375+...
example0500.cpp
    定义了长度的数组,系统会自动加上结尾符.没有定义长度的数组,系统并不会自动加上结尾符,会一直去寻找结尾符.
        0xcccc=烫
        低字节，高地址。高字节，低地址。----->大端存储
        低字节，低地址。高字节，高地址。----->小端存储
        计算数组长度函数:strlen<strlen>
example0501.cpp
    _countof()：获取元素个数，会计算字符串""的结尾符
        没有声明数组大小的情况下，结果为数组的实际元素个数(花括号内的数组元素个数)。
        在声明数组大小的情况下，结果为声明的数组大小，而非数组的实际元素个数。
        ==>_countof()是委员C语言标准库提供的函数
    sizeof()：数组的总位数(字节 byte)，会计算字符串""的结尾符
        没有声明数组大小的情况下，结果为数组的实际元素个数*字节(花括号内的数组元素个数*字节)。
        在声明数组大小的情况下，结果为声明的数组大小，而非数组的实际元素个数*字节。
    stelen()：获取元素个数
        char类型数组中，0和'\0'是结尾符，但'0'不是结尾符，以双引号""定义的数组会默认结尾有结尾符。
        没有声明数组大小的情况下，结果为寻找到结尾符为止(长度可能会超过想象)。
        在声明数组大小的情况下，有结尾符时，结果为结尾符前的元素个数，没有结尾符时，结果为数组的元素个数。
example0600.cpp
    *:获取地址值指向的内容
    &:获取地址值所在(指针变量本身)的地址值

    指针变量也是有不同类型的的,例如:int*,char*
    指针变量+n=指针地址的值+指针变量的字节大小*n

    指针的大小为8(无符号整型,16位=2btye,32位=4byte,64位=8btye)
    指针变量的大小根据定义指针的类型(指针所指向的内容的类型)决定,例:char* 1,int* 4
example0601.cpp
    数组也是一种指针,指向的是数组的首元素
    指针也能当成数组使用,指针可以使用下标访问数组元素
    数组名自身就是指向数组「第一个元素」的指针，因此指针法可以直接作用于数组名,数组名实际上是一个地址(不可用于++操作,因地址是不可修改的)
example0602.cpp
    指针常量:指针类型的常量(指针自身的值是一个常量,即指向的地址不能被改变,但指向的地址的内容可以被改变),保护地址不变
        地址不可变,地址指向的值可变(p不可变,*p可变)
            定义方式:*在前,const在后(指针常量)
                类型* const 变量名
    常量指针:指向常量的指针(指针指向的内容是不能改变的),保护地址的值不变
        地址可变,地址指向的值不可变(p可变,*p不可变)
            定义方式:const在前,*在后(常量指针)
                类型 const* 变量名;
                const 类型* 变量名;
example0603.cpp
    strcpy能把strSrc的内容复制到strDest，为什么还要char * 类型的返回值？
        答：为了实现链式表达式。例如 int length = strlen( strcpy( strDest, “hello world”) );
example0701.cpp
    指针做形参时:p无效,*p有效
        指针形参(p)交换不会改变实参
        指针形参值(*p)交换会改变实参值
    不交换
        int、p
    交换
        int&、*p
example0702.cpp
    静态局部变量在静态存储区分配空间,程序仅分配一次内存;函数返回后,该静态局部变量并不会消失.
    静态局部变量具有局部作用域,只对定义自己的函数体始终可见,函数推出后,变量还存在,但不可用.
example0703.cpp
    结构体的定义,定义时并没有申请内存空间(变量在定义时就会申请内存空间),结构体在构建对象时才会进行内存空间申请
    typedef关键字为结构体重新命名:
        第一种:重命名和定义同时进行
        第二种:先定义结构体,再重新为结构体命名
    结构体对象赋值的三种方式:使用赋值符号(=)、调用memcpy函数丶逐个成员变量的数据复制
        字符串数组不能直接使用赋值符号进行数据赋值,需要使用strcpy函数进行赋值
example0704.cpp
    利用指针修改结构体内的单个数据
        指针法修改数据,.的优先级比*高,所以需要给*加上(),以提升*的优先级.
            ((*p).nNumb = 1003;)
        指针符号法修改数据
            p->fSala = 8887.77f;
    修改结构体内的数组数据时,使用strcpy_s函数
        strcpy_s(w1.sName, w2.sName);
example0705.cpp
    结构体指针做形参时:p修改无效,*p(p[i])修改有效
example0800.cpp
    数组做参数时，数组会退化为指针，而sizeof(数组名)和sizeof(指针)是有区别的，所以需要传入所需的数组大小。
        sizeof(指针)是指针变量的大小(本身所占的内存字节数均为8,也就是要使用8个字节的大小来存储指针的值)，不是计算指针类型的大小(字节)。
        _countof和sizeof会计算字符串数组的结尾符，真实字符串长度应减一。
        使用strlen更好，不会计算字符串数组的结尾符。
    fopen：打开并获取文件流。fclose：关闭打开的文件流。
    fread：从文件中读取内容。fwrite：往文件中写入内容。
    fseek：将文件位置指针移动到指定位置，第二个参数为偏移量，第三个参数为偏移起点。
        SEEK_SET(0)：文件头
        SEEK_CUR(1)：当前位置
        SEEK_END(2)：文件尾
    ftell：获取文件位置指针的当前位置相对于文件首的偏移字节数
    rewind：将文件位置指针移动到文件头。
    malloc：在内存中开辟空间。free：回收内存空间。
example0801.cpp
    进入if循环的条件为非0，不单单是1。以下条件都可以进入循环
        !NULL
        -1
        "abcd"
        "C/C++老师"
        88.09
example1000.cpp
    指针
        一级指针：*p
        二级指针：**p
        n级指针：**..**p
        数组(数组名实际上就是定位数组第一个元素的位置，不可更改：++)：a[]
        指针数组(为数组，该数组的内容是，指向指定类型变量的指针)：char* p[]
            char* p[] = {"C语言指针数组"};
            上面p为指针数组，有一个元素，为char类型指针，该指针指向的内容是(C语言指针数组)
        数组指针(为指针，该指针指向的是，n个元素的p数组)：char (*p)[n]
            正确定义：
                int tmp[3] = {1,2,3};
                int (*p)[3] = &tmp;
            错误定义：
                1、int (*p)[3] = {1,2,3};
                2、int tmp[3] = {1,2,3};int (*p)[3] = tmp;
        二维数组(使用数组指针来访问二维数组)：int a[][]
            int a[2][4] = int (*a)[4]
                上面是定义了两个指针(*a)，每个指针都指向一个大小为4的数组。
                上面a之间a+1相隔4个int类型变量，a指向的是a[0][0]，a+1指向的是a[1][0]。
            数组指针访问二维数组：
            例：*(*(a+1)+2)指向的是a[1][2]
                *(array + i) == array[i]
                *(*(array + i) + j) == array[i][j]
                *(*(*(array + i) + j) + k) == array[i][j][k]
        常量指针(指向常量的指针，保护指针的地址不变)：
            const int* p
            const* int p
<==